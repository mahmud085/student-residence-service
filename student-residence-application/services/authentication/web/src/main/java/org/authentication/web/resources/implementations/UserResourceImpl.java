package org.authentication.web.resources.implementations;

import com.google.inject.Inject;
import org.authentication.common.Messages;
import org.authentication.common.exceptions.ObjectNotFoundException;
import org.authentication.dataaccess.data.models.User;
import org.authentication.service.models.RegisterUser;
import org.authentication.service.models.UserRole;
import org.authentication.service.services.interfaces.UserService;
import org.authentication.web.Constants;
import org.authentication.web.resources.interfaces.UserResource;

import javax.annotation.security.RolesAllowed;
import javax.ws.rs.*;
import javax.ws.rs.core.*;

@Path(Constants.RESOURCE_PATH_USER)
@Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
public class UserResourceImpl implements UserResource {
    @Inject
    private UserService userService;

    @Context
    private UriInfo uriInfo;

    @Context
    private SecurityContext securityContext;

    @Override
    @GET
    @RolesAllowed({Constants.ROLE_ADMIN, Constants.ROLE_CARETAKER, Constants.ROLE_RESIDENT})
    @Path("{user-id}")
    public Response getUser(@PathParam("user-id") String userId) {
        if (userId == null || userId.length() == 0) {
            return buildResponseObject(Response.Status.BAD_REQUEST, Messages.REQUEST_BODY_REQUIRED);
        }

        String contextUserId = securityContext.getUserPrincipal().getName();
        boolean isAdminUser = securityContext.isUserInRole(Constants.ROLE_ADMIN);
        boolean isCaretaker = securityContext.isUserInRole(Constants.ROLE_CARETAKER);
        boolean isUserAuthorizedForThisResource = isAdminUser || isCaretaker || userId.equalsIgnoreCase(contextUserId);

        if (!isUserAuthorizedForThisResource) {
            return buildResponseObject(Response.Status.UNAUTHORIZED, Messages.USER_NOT_AUTHORISED_TO_OPERATE_RESOURCE);
        }

        try {
            User user = userService.getUser(userId);

            return buildResponseObject(Response.Status.OK, user);
        } catch (ObjectNotFoundException e) {
            return buildResponseObject(Response.Status.BAD_REQUEST, e.getMessage());
        } catch (Exception e) {
            return buildResponseObject(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());
        }
    }

    @Override
    @POST
    @RolesAllowed({Constants.ROLE_ADMIN})
    public Response createUser(RegisterUser newUser) {
        if (newUser == null ) {
            return buildResponseObject(Response.Status.BAD_REQUEST, Messages.REQUEST_BODY_REQUIRED);
        }

        try {
            newUser.setPassword("autogenerated");
            newUser.setName("doesNotMatter");
            newUser.setRole(UserRole.Resident);

            User user = userService.registerUser(newUser);

            return buildResponseObject(Response.Status.OK, user);
        } catch (Exception e) {
            return buildResponseObject(Response.Status.BAD_REQUEST, e.getMessage());
        }
    }

    private <T> Response buildResponseObject(Response.Status status, T entity) {
        return Response.status(status)
                .entity(entity)
                .build();
    }
}
